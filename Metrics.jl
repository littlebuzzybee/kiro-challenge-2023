
function relu(x)
    return max(0, x)
end


function Cn(x, z, y_ls, ω) #(5) suivant le même découpage
    cn = 0.0;
    for v in used_substations
        p_gen_turb_lin_v = πw[ω] * sum( z[v,t] for t in 1:Vt ); # power generated by turbines linked to v
        capa_link_v = min(sum(rs[s]*x[v,s] for s in 1:Ss), sum(rq_ls[q]*y_ls[v,q] for q in 1:Q0)); # capacity of the cable/subsattion linking v
        cn +=  relu(p_gen_turb_lin_v  -  capa_link_v);
    end
    return cn;
end



function Cf(x, y_ss, z, y_ls, ω, v) #(6) suivant le même découpage
    cf = 0.0;
    
    if v < Vs && (v in used_substations)
        cf += relu(πw[ω]*sum(z[v,:]) - 0.5*sum( rq_ss[q] *  y_ss[v,vbar,q]  for q in 1:Qs, vbar in (v+1):Vs )); # curtailing of v under ω and failure of v
    end
    
    
    for vbar in used_substations # deleteat!(copy(used_substations), findall(x->x==v,used_substations))
        if vbar != v
            pow_gen_turb_lin_v = πw[ω]*sum(z[vbar,:]); # power generated by turbines linked to vbar
            pow_sent_from_v_to_vbar = min( sum( rq_ss[q]*y_ss[v,vbar,q] for q in 1:Qs ), πw[ω]*sum(z[v,:]) ); # power sent from v to vbar
            capa_station_linking_v = min( sum( rs[s]*x[vbar,s] for s in 1:Ss ), sum( rq_ls[q]*y_ls[vbar,q] for q in 1:Q0 )); # capacity of the cable/subsattion linking vbar

            cf += relu(
                pow_gen_turb_lin_v + pow_sent_from_v_to_vbar - capa_station_linking_v;
            ); # curtailing of vbar under scenario ω and failure of v
        end
    end
    return cf
end






cc = C -> c0*C + cp*relu(C - Cmax);


function pf(x, y_ls, v)
    pf = 0.0;
    pf += sum([ps[s] * x[v, s] for s in 1:Ss]);   # sum(x[v,:]' * ps)
    pf += sum([pq[q] * y_ls[v,q] for q in 1:Q0]); # sum(y_ls[v,:]' * pq)
    return pf
end

function loss(x, y_ss, z, y_ls) #(7)
    x = value.(x);
    y_ss = value.(y_ss);
    y_ls = value.(y_ls);
    z = value.(z);


    constr_cost = 0.0;
    ## CONSTRUCTION COST
    constr_cost += onesVs' * x * cs; # coûts de construction des sous-stations
    constr_cost += onesVs' * y_ls * cqf_ls + dls' * y_ls * cql_ls; # coûts des câbles entre land et sous-stations
    constr_cost += sum(ctf * z + ctl * dsw .* z); # coûts des câbles entre land et éoliennes
    
    for q=1:Qs
        # facteur 1/2 car la matrice est symétrique à diagonale nulle et donc on compte deux fois chaque câble
        constr_cost += .5 *  sum(cql_ss[q] * y_ss[:,:,q] .* dss); # coûts linéaires des câbles entre sous-stations
        constr_cost += .5 *  sum(cqf_ss[q] * y_ss[:,:,q]); # coûts fixes des câbles entre sous-stations
    end


    ## OPERATIONAL COST

    proba_fail = 0.0;
    for v in used_substations
        proba_fail += pf(x, y_ls, v);
    end

    op_cost_fail = 0.0;
    op_cost_nofail = 0.0;
    for ω in 1:Nws
        op_cost_fail   += sum( pw[ω] * cc(Cf(x, y_ss, z, y_ls, ω, v)) for v in used_substations);
        op_cost_nofail += pw[ω] * cc(Cn(x, z, y_ls, ω));
    end

    op_cost_fail *= proba_fail;
    op_cost_nofail *= 1-proba_fail;

    
    cost = constr_cost + op_cost_fail + op_cost_nofail;

    return constr_cost, op_cost_fail, op_cost_nofail, cost;
end


convert = val -> Bool.(round.(value.(val)));