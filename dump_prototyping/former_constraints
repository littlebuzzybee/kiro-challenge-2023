    # cables betweens substations and turbines
    #= former constraints (do not work)
    for v=1:Vs
        @constraint(model, ~(z[v,:]'*onesVt >= 1) .|| (x[v,:]'*onesVs) := true);
    end
    =#
    
    #=
    ∃_substation_at_location = sum(x, dims=2);
    for v=1:Vs
        for t=1:Vt
            @constraint(model, (1-z[v,t]) || ∃_substation_at_location[v] := true)
        end
    end
    =#

    #=
    @constraint(model, (x * Bool.(onesSs) .>= 1) .== (z * Bool.(onesVt) .>= 1));
    =#
    
    
    
    
    
    
    # ci-après le code pour les contraintes par blocs carrés d'éoliennes et leurs points d'attache 
    # (au lieu de considérere chaque ligne, on fonctionne ici par bloc mais du fait de la numérotation spatiale malaisée des éoliennes suivant les instances j'ai abandonné
    
        @variable(model, turb_connect[1:8, 1:3], Bin)
        for s=1:Ss # force group turbines by substation 
            for tu=1:7
                for tv=1:3
                    offset = 1 + (tv-1)*3 + (tu-1)*18;
                    for stride=0:2
                        @constraint(model, z[s, offset+stride]    == turb_connect[tu, tv]);
                        @constraint(model, z[s, offset+stride+18] == turb_connect[tu, tv]);
                    end
                end
            end

            for t=127:129
                @constraint(model, z[s, t] == turb_connect[8, 1]);
            end
            for t=130:132
                @constraint(model, z[s, t] == turb_connect[8, 2]);
            end
            for t=133:135
                @constraint(model, z[s, t] == turb_connect[8, 3]);
            end
        end
        
        
        
        
        
        
        
        
    # si une liaison entre deux sous-stations est présente, alors les deux sous-stations doivent être présentes
    # for v1=1:Vs-1
    #     for v2=v1:Vs
    #         for q=1:Qs
    #             @constraint(model, y_ss[v1,v2,q] => {sum(x[v1,:]) >= 1});
    #             @constraint(model, y_ss[v1,v2,q] => {sum(x[v2,:]) >= 1});
    #         end
    #     end 
    # end
    
    
    
    
    # ci-dessous la structure de l'ajout des coûts opérationnels avant l'optimisation (sur les stations utilisées seulement) et faisant la somme sur tous les scénarios (ce qui est inutilement complexe
    
    #=     operational_cost = QuadExpr();
    for ω in 1:Nws
        for v in 1:(Vs-1) # to avoid MethodError
            pf_v = x[v,:]'*ps + y_ls[v,:]'*pq; # probability of failure of the station in v or the cable linking it to v0
            cst_mlt = pf_v*c0;
            #from (6): curtailing of v under ω and failure of v

            
            add_to_expression!(operational_cost,   cst_mlt * πw[ω] * (z[v,:]'*onesVt));
            add_to_expression!(operational_cost, - cst_mlt * sum(y_ss[v,vbar,:]' * rq_ss for vbar in (v+1):Vs)); 

            # from (6): curtailing of vbar under scenario ω and failure of v
            # for vbar=(v+1):Vs
            #     add_to_expression!(operational_cost, cst_mlt * πw[ω] *  sum(z[vbar,:])); # power generated by turbines linked to v0
            #     add_to_expression!(operational_cost, cst_mlt * (y_ss[v,vbar,:]'*rq_ss +  πw[ω]*sum(z[v,:]))); # power sent from v to vbar
            #     add_to_expression!(operational_cost, -cst_mlt * (x[vbar,:]'*rs +  y_ls[vbar,:]'*rq_ls)); # capacity of the cable/subsattion linking vbar
            # end
        end
    end =#
